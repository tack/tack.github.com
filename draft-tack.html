<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">TLS Working Group</td><td class="header">M. Marlinspike</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">T. Perrin, Ed.</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">January 7, 2013</td></tr>
<tr><td class="header">Expires: July 11, 2013</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Trust Assertions for Certificate Keys<br />draft-perrin-tls-tack-02.txt</h1>

<h3>Abstract</h3>

<p>

This document defines a TLS Extension that enables a TLS server to support
"pinning" to a self-chosen signing key. A client contacting a pinned host will
require the server to present a signature from the signing key over the TLS
server's public key.

			
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on July 11, 2013.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2013 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor1">1.1.</a>&nbsp;
Requirements notation<br />
<a href="#anchor2">2.</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">2.1.</a>&nbsp;
Tack life cycle<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.2.</a>&nbsp;
Pin life cycle<br />
<a href="#anchor5">3.</a>&nbsp;
TACK Extension<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.1.</a>&nbsp;
Definition of TackExtension<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.2.</a>&nbsp;
Explanation of TackExtension fields<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">3.2.1.</a>&nbsp;
Tack fields<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.2.2.</a>&nbsp;
TackExtension fields<br />
<a href="#clientproc">4.</a>&nbsp;
Client processing<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">4.1.</a>&nbsp;
TACK pins<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.2.</a>&nbsp;
High-level client processing<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#details">4.3.</a>&nbsp;
Client processing details<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#wellformed">4.3.1.</a>&nbsp;
Check whether the TLS handshake is valid<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.3.2.</a>&nbsp;
Check tack generations and update min_generations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.3.3.</a>&nbsp;
Determine the store's status<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#creating">4.3.4.</a>&nbsp;
Pin activation (optional)<br />
<a href="#anchor14">5.</a>&nbsp;
Application protocols and TACK<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">5.1.</a>&nbsp;
Pin scope<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">5.2.</a>&nbsp;
TLS negotiation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#certver">5.3.</a>&nbsp;
Certificate verification<br />
<a href="#anchor17">6.</a>&nbsp;
Fingerprints<br />
<a href="#anchor18">7.</a>&nbsp;
Advice<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#servadvice">7.1.</a>&nbsp;
For server operators<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">7.2.</a>&nbsp;
For client implementers<br />
<a href="#security">8.</a>&nbsp;
Security considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">8.1.</a>&nbsp;
For server operators<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#security_client">8.2.</a>&nbsp;
For client implementers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#future">8.3.</a>&nbsp;
Note on algorithm agility<br />
<a href="#anchor21">9.</a>&nbsp;
IANA considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">9.1.</a>&nbsp;
New entry for the TLS ExtensionType Registry<br />
<a href="#anchor23">10.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">11.</a>&nbsp;
Normative references<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>

Traditionally, a TLS client verifies a TLS server's public key using a
certificate chain issued by some public CA. "Pinning" is a way for clients to
obtain increased certainty in server public keys. Clients that employ pinning
check for some constant "pinned" element of the TLS connection when
contacting a particular TLS host.

 
</p>
<p>

TACK allows clients to pin to a server-chosen signing key, known as a "TACK
signing key" or "TSK", which signs the server's TLS keys. This enables pinning
without limiting a site's flexibility to deploy different certificates and TLS
keys on different servers or at different times. Since pins are based on TSKs
instead of CA keys, trust in CAs is not required. Additionally, a TSK may be
used to revoke compromised TLS private keys, and a pair of "overlapping" TSKs
may be used to quickly introduce a new TSK if an older one has become
compromised or suspect.

 
</p>
<p>

If requested, a compliant server will send a TLS Extension containing its
"tack". Inside the tack is a TSK public key and signature. Once a client has
seen the same (hostname, TSK) pair multiple times, the client will "activate"
a pin between the hostname and TSK for a period equal to the length of time
the pair has been observed for. This "pin activation" algorithm limits the
impact of bad pins resulting from transient network attacks or operator error.

			
</p>
<p>

TACK pins are easily shared between clients. For example, a TACK client may
scan the internet to discover TACK pins, then publish these pins through some
3rd-party trust infrastructure for other clients to rely upon.


</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Requirements notation</h3>

<p>The key words "MUST",
"MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Overview</h3>

<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Tack life cycle</h3>

<p>A server operator using TACK may perform several processes:

	</p>
<blockquote class="text"><dl>
<dt>Selection of a TACK signing key (TSK):</dt>
<dd>	

The server operator first chooses the ECDSA signing key to use for a set of
hostnames. It is safest to use a different TSK for each hostname, though a TSK
may be reused for closely-related hostnames (such as aliases for the same
host, or hosts sharing the same TLS key).

	
</dd>
<dt>Creating initial tacks under a TSK:</dt>
<dd>

The TSK private key is then used to sign the TLS public keys for all servers
associated with those hostnames. The TSK public key and signature are
combined with some metadata into each server's "tack".

	
</dd>
<dt>Deploying initial tacks:</dt>
<dd>	

For each hostname, tacks are deployed to TLS servers in a two-stage process.
First, each TLS server associated with the hostname is given a tack. Once this
is completed, the tacks are activated by setting the "activation flag" on each
server.

	
</dd>
<dt>Creating new tacks under a TSK:</dt>
<dd>	

A tack needs to be replaced whenever a server changes its TLS public key, or
when the tack expires. Tacks may also need to be replaced with
later-generation tacks if the TSK's "min_generation" is updated (see
next).

	
</dd>
<dt>Revoking old tacks:</dt>
<dd>

If a TLS private key is compromised, the tacks signing this key can be revoked
by publishing a new tack containing a higher "min_generation".

	
</dd>
<dt>Deactivating tacks:</dt>
<dd>

If a server operator wishes to stop deploying tacks, all tacks for a hostname
can be deactivated via the activation flag, allowing the server to remove the
tacks within 30 days (at most).

	
</dd>
<dt>Overlapping tacks:</dt>
<dd>

If a server operator wishes to change the TSK a hostname is pinned to,
the server can publish a new tack alongside the old one. This lets clients
activate pins for the new TSK prior to the server deactivating the older
pins.

	
</dd>
</dl></blockquote><p>
		

</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Pin life cycle</h3>

<p>

A TACK pin associates a hostname and a TSK. Pins are grouped into "pin
stores". A client may populate its pin stores by either performing "pin
activation" directly, or by querying some other party. For example, a client
application may have a store for pin activation as well as a store whose
contents are periodically fetched from a server. 
</p>
<p>

Whenever a client performing "pin activation" sees a hostname and TSK
combination not represented in the "pin activation" pin store, an inactive pin
is created. Every subsequent time the client sees the same pin, the pin is
"activated" for a period equal to the timespan between the first time the pin
was seen and the most recent time, up to a maximum period of 30 days.


</p>
<p>

A pin store may contain up to two pins per hostname. This allows for
overlapping pins when a server is securely transitioning from one pin to
another. If both pins are simultaneously active, then the server must satisfy
both of them by presenting a pair of tacks.


</p>
<p>In addition to creating and activating pins, a TLS connection can alter
client pin stores by publishing new "min_generation" values in a tack. Each
pin stores the highest "min_generation" value it has seen from the pinned TSK, and rejects tacks from earlier generations.

</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
TACK Extension</h3>

<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Definition of TackExtension</h3>

<p>

A new TLS ExtensionType ("tack") is defined and MAY be included by a TLS
client in the ClientHello message defined in <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a>.


</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
enum {tack(TBD), (65535)} ExtensionType;
</pre></div>
<p>

The "extension_data" field of this ClientHello extension SHALL be empty. A TLS
server which is not resuming a TLS session MAY respond with an extension of
type "tack" in the ServerHello. The "extension_data" field of this
ServerHello extension SHALL contain a "TackExtension", as defined below using
the TLS presentation language from <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a>.

	
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
struct {
   opaque public_key[64];
   uint8  min_generation;
   uint8  generation;
   uint32 expiration;
   opaque target_hash[32];
   opaque signature[64];
} Tack;   /* 166 bytes */

struct {
   Tack   tacks&lt;166...332&gt;   /* 1 or 2 tacks */
   uint8  activation_flags;
} TackExtension;   /* 169 or 335 bytes */
</pre></div>
<p>
	


</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Explanation of TackExtension fields</h3>

<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
Tack fields</h3>

<p>
</p>
<blockquote class="text"><dl>
<dt>public_key:</dt>
<dd>

Specifies the public key of the TSK that has signed this tack. The field
contains a pair of integers (x, y) representing a point on the elliptic curve
P-256 defined in <a class='info' href='#FIPS186-3'>[FIPS186&#8209;3]<span> (</span><span class='info'>National Institute of Standards and Technology, &ldquo;Digital Signature Standard,&rdquo; June&nbsp;2009.</span><span>)</span></a>. Each integer is encoded as a
32-byte octet string using the Integer-to-Octet-String algorithm from <a class='info' href='#RFC6090'>[RFC6090]<span> (</span><span class='info'>McGrew, D., Igoe, K., and M. Salter, &ldquo;Fundamental Elliptic Curve Cryptography Algorithms,&rdquo; February&nbsp;2011.</span><span>)</span></a>, and these strings are concatenated with the x value first.
(NOTE: This is equivalent to an uncompressed subjectPublicKey from <a class='info' href='#RFC5480'>[RFC5480]<span> (</span><span class='info'>Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk, &ldquo;Elliptic Curve Cryptography Subject Public Key Information,&rdquo; March&nbsp;2009.</span><span>)</span></a>, except that the initial 0x04 byte is omitted).

	
</dd>
<dt>min_generation:</dt>
<dd> 

Publishes a min_generation for the tack's TSK.


</dd>
<dt>generation:</dt>
<dd> 

Assigns each tack a generation. Generations less than the highest published
min_generation for the tack's TSK are considered revoked.


</dd>
<dt>expiration:</dt>
<dd> 

Specifies a time after which the tack is considered expired. The time is
encoded as the number of minutes, excluding leap seconds, after midnight UTC,
January 1 1970. 
</dd>
<dt>target_hash:</dt>
<dd> 

A hash of the TLS server's SubjectPublicKeyInfo <a class='info' href='#RFC5280'>[RFC5280]<span> (</span><span class='info'>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,&rdquo; May&nbsp;2008.</span><span>)</span></a> using
the SHA256 algorithm from <a class='info' href='#FIPS180-2'>[FIPS180&#8209;2]<span> (</span><span class='info'>National Institute of Standards and Technology, &ldquo;Secure Hash Standard,&rdquo; August&nbsp;2002.</span><span>)</span></a>. The SubjectPublicKeyInfo
is typically conveyed as part of the server's X.509 end-entity certificate.


</dd>
<dt>signature:</dt>
<dd>

An ECDSA signature by the tack's TSK over the 8 byte ASCII string "tack_sig"
followed by the contents of the tack prior to the "signature" field (i.e. the
preceding 102 bytes). The field contains a pair of integers (r, s)
representing an ECDSA signature as defined in <a class='info' href='#FIPS186-3'>[FIPS186&#8209;3]<span> (</span><span class='info'>National Institute of Standards and Technology, &ldquo;Digital Signature Standard,&rdquo; June&nbsp;2009.</span><span>)</span></a>,
using curve P-256 and SHA256. Each integer is encoded as a 32-byte octet
string using the Integer-to-Octet-String algorithm from <a class='info' href='#RFC6090'>[RFC6090]<span> (</span><span class='info'>McGrew, D., Igoe, K., and M. Salter, &ldquo;Fundamental Elliptic Curve Cryptography Algorithms,&rdquo; February&nbsp;2011.</span><span>)</span></a>, and these strings are concatenated with the r value first.


</dd>
</dl></blockquote><p>

</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
TackExtension fields</h3>

<p>
</p>
<blockquote class="text"><dl>
<dt>tacks:</dt>
<dd>

This field provides the server's tack(s). It SHALL contain 1 or 2 tacks. 
</dd>
<dt>activation_flags:</dt>
<dd>

This field contains "activation flags" for the extension's tacks. If the low
order bit is set, the first tack is considered active. If the next lowest bit
is set, the second tack is considered active. All other bits are reserved for
future use and MUST be ignored by clients.



</dd>
</dl></blockquote><p> 
</p>
<a name="clientproc"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Client processing</h3>

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
TACK pins</h3>

<p>

A client SHALL have a local store of pins, and MAY have multiple stores. Each
pin store consists of a map associating fully qualified DNS hostnames with
either one or two sets of the following values:

</p>
<blockquote class="text"><dl>
<dt>Initial time:</dt>
<dd>

A timestamp noting when this pin was created.


</dd>
<dt>End time:</dt>
<dd>

A timestamp determining the pin's "active period". If set to zero or a
time in the past, the pin is "inactive". If set to a future time, the pin is
"active" until that time.


</dd>
<dt>TSK public key (or hash):</dt>
<dd>

A public key or a cryptographically-secure, second preimage-resistant hash of
a public key.


</dd>
<dt>Min_generation:</dt>
<dd>

A single byte used to detect revoked tacks. All pins within a pin store
sharing the same TSK SHALL have the same min_generation.


</dd>
</dl></blockquote><p>

</p>
<p>

A hostname along with the above values comprises a "TACK pin". Thus, each
store can hold up to two pins for a hostname (however, those two pins MUST
reference different public keys). A pin "matches" a tack if they reference the
same public key. A pin is "relevant" if its hostname equals the TLS server's
hostname.


</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
High-level client processing</h3>

<p>

A TACK client SHALL send the "tack" extension defined previously, and SHALL
send the "server_name" extension from <a class='info' href='#RFC6066'>[RFC6066]<span> (</span><span class='info'>Eastlake, D., &ldquo;Transport Layer Security (TLS) Extensions: Extension Definitions,&rdquo; January&nbsp;2011.</span><span>)</span></a>. If not
resuming a session, the server MAY respond with a TackExtension. Regardless of
whether a TackExtension is returned, the client SHALL perform the following
steps prior to using the connection:

</p>
<ol class="text">
<li>Check whether the TLS handshake is "valid".
</li>
<li>For each pin store, do:

<blockquote class="text"><dl>
<dt>A.</dt>
<dd>Check tack generations and update min_generations.
</dd>
<dt>B.</dt>
<dd>Determine the store's status.
</dd>
<dt>C.</dt>
<dd>Perform pin activation (optional).
</dd>
</dl></blockquote>

	


</li>
</ol><p>

These steps SHALL be performed in order. If there is any error, the client
SHALL send a fatal error alert and close the connection, skipping the
remaining steps (see <a class='info' href='#details'>Section&nbsp;4.3<span> (</span><span class='info'>Client processing details</span><span>)</span></a> for details).


</p>
<p>Based on step 2B, each store will report one of three statuses for the
connection: "confirmed", "contradicted", or "unpinned". A contradicted
connection might indicate a network attack. How the client responds to
confirmed or contradicted connections is left to other specifications and
client policy (see <a class='info' href='#certver'>Section&nbsp;5.3<span> (</span><span class='info'>Certificate verification</span><span>)</span></a> for an example). If a client
closes a connection due to a contradicting pin, the client SHALL send an
"access_denied" alert. 
</p>
<a name="details"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Client processing details</h3>

<a name="wellformed"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
Check whether the TLS handshake is valid</h3>

<p>

A TLS handshake is "valid" if the following are true. Unless otherwise
specified, if any of the following are false a "bad_certificate" fatal error
alert SHALL be sent.

</p>
<ol class="text">
<li>The handshake protocol negotiates a cryptographically secure ciphersuite
and finishes succesfully.
</li>
<li>If a TackExtension is present then all length fields are correct and the
tacks are "valid" (see below).
</li>
<li>If there are two tacks, they have different "public_key" fields.
</li>
</ol><p> 

</p>
<p>
A tack is "valid" if:	
</p>
<ol class="text">
<li>"generation" is >= "min_generation".
</li>
<li>"expiration" specifies a time in the future, otherwise the client SHALL
send a fatal "certificate_expired" error alert.
</li>
<li>"target_hash" is a correct hash of the SubjectPublicKeyInfo.
</li>
<li>"signature" is a correct ECDSA signature.
</li>
</ol><p> 
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
Check tack generations and update min_generations</h3>

<p>If a tack has matching pins in the pin store and a generation less than the
stored min_generation, then that tack is revoked and the client SHALL send a
fatal "certificate_revoked" error alert. If a tack has matching pins and a
min_generation greater than the stored min_generation, the stored value SHALL
be set to the tack's value.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3"></a><h3>4.3.3.&nbsp;
Determine the store's status</h3>

<p>

If there is a relevant active pin without a matching tack, then the connection
is "contradicted". If the connection is not contradicted and there is a
relevant active pin with a matching tack, then the connection is "confirmed".
Otherwise, the connection is "unpinned".


</p>
<a name="creating"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.4"></a><h3>4.3.4.&nbsp;
Pin activation (optional)</h3>

<p>

The TLS connection MAY be used to create, delete, and activate pins. This "pin
activation algorithm" is optional; a client MAY rely on an external source of
pins. If the connection was "contradicted" by the previous processing step,
then pin activation is skipped.


</p>
<p>

The first step is to evaluate each of the (0, 1, or 2) relevant pins: </p>
<ol class="text">
<li>If a pin has no matching tack, its handling will depend on whether the pin
is active. If active, the connection will have been contradicted, skipping pin
activation. If inactive, the pin SHALL be deleted.
</li>
<li>If a pin has a matching tack, its handling will depend on whether the tack
is active. If inactive, the pin is left unchanged. If active, the pin SHALL
have its "end time" set based on the current, initial, and end times:

<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    end = current + MIN(30 days, current - initial)
</pre></div> 
</li>
</ol><p> 
</p>
<p> In sum: (1) deletes unmatched inactive pins, and (2) activates matched
pins with active tacks. 
</p>
<p>The remaining step is to add new inactive pins for any unmatched active
tacks. Each new pin uses the server's hostname, the tack's public key and
min_generation (unless the store has a higher min_generation for the public
key), an "initial time" set to the current time, and an "end time" of zero.
(Note that there are always sufficient empty "slots" in the pin store for
adding new pins without exceeding two pins per hostname.)


</p>
<p>The following tables summarize this behavior from the perspective of a pin.
You can follow the lifecycle of a single pin from "New inactive pin" to
"Delete pin".




</p>
<p>Relevant pin is active:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">Pin matches a tack</th><th align="left">Tack is active</th><th align="left">Result</th></tr>
<tr>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">Extend activation period</td>
</tr>
<tr>
<td align="left">Yes</td>
<td align="left">No</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">No</td>
<td align="left">-</td>
<td align="left">(Connection contradicted)</td>
</tr>
</table>
<br clear="all" />

<p>Relevant pin is inactive:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">Pin matches a tack</th><th align="left">Tack is active</th><th align="left">Result</th></tr>
<tr>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">Activate pin</td>
</tr>
<tr>
<td align="left">Yes</td>
<td align="left">No</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">No</td>
<td align="left">-</td>
<td align="left">Delete pin</td>
</tr>
</table>
<br clear="all" />

<p>Tack doesn't match any relevant pin:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Unmatched tack is active</th><th align="left">Result</th></tr>
<tr>
<td align="left">Yes</td>
<td align="left">New inactive pin</td>
</tr>
<tr>
<td align="left">No</td>
<td align="left">-</td>
</tr>
</table>
<br clear="all" />

<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Application protocols and TACK</h3>

<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Pin scope</h3>

<p> TACK pins are specific to a particular application protocol. In other
words, a pin for HTTPS at "example.com" implies nothing about POP3 or SMTP at
"example.com". 
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
TLS negotiation</h3>

<p>Some application protocols negotiate TLS as an optional feature (e.g. SMTP
using STARTTLS <a class='info' href='#RFC3207'>[RFC3207]<span> (</span><span class='info'>Hoffman, P., &ldquo;SMTP Service Extension for Secure SMTP over Transport Layer Security,&rdquo; February&nbsp;2002.</span><span>)</span></a>). If such a server does not negotiate
TLS and there are relevant active pins, then the connection is contradicted by
the pin. If a client is performing pin activation for a pin store and the
server does not negotiate TLS, then any relevant, inactive pins SHALL be
deleted. Note that these steps are taken despite the absence of a TLS
connection.
</p>
<a name="certver"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Certificate verification</h3>

<p>

A TACK client MAY choose to perform some form of certificate verification in
addition to TACK processing. When combining certificate verification and TACK
processing, the TACK processing described in <a class='info' href='#clientproc'>Section&nbsp;4<span> (</span><span class='info'>Client processing</span><span>)</span></a> SHALL
be followed, with the exception that TACK processing MAY be terminated early
(or skipped) if some fatal certificate error is discovered.


</p>
<p>

If TACK processing and certificate verification both complete without a fatal
error, then client behavior is left to other specifications and client policy.
An example client policy would be to allow the connection to proceed only if
it passes certificate verification and is not contradicted by a pin.


</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Fingerprints</h3>

<p>

A "key fingerprint" may be used to represent a TSK public key to users in a
form that is easy to compare and transcribe. A key fingerprint consists of the
first 25 characters from the base32 encoding of SHA256(public_key), split into
5 groups of 5 characters separated by periods. Base32 encoding is as specified
in <a class='info' href='#RFC4648'>[RFC4648]<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a>, except lowercase is used. Examples:


</p>
<p>
</p>
<blockquote class="text">
<p>g5p5x.ov4vi.dgsjv.wxctt.c5iul
</p>
<p>quxiz.kpldu.uuedc.j5znm.7mqst
</p>
<p>e25zs.cth7k.tscmp.5hxdp.wf47j
</p>
</blockquote><p>

</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Advice</h3>

<a name="servadvice"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
For server operators</h3>

<p>
</p>
<blockquote class="text"><dl>
<dt>Key reuse:</dt>
<dd>

All servers that are pinned to a single TSK are able to impersonate each
other's hostnames, since clients will perceive their tacks as equivalent.
Thus, TSKs SHOULD NOT be reused with different hostnames unless these
hostnames are closely related. Examples where it would be safe to reuse a TSK
are hostnames aliased to the same host, hosts sharing the same TLS key, or
hostnames for a group of near-identical servers.


</dd>
<dt>Aliases:</dt>
<dd>

A TLS server might be referenced by multiple hostnames. Clients might pin any
of these hostnames. Server operators should be careful when using DNS aliases
that hostnames are not pinned inadvertently.


</dd>
<dt>Generations:</dt>
<dd>

To revoke older generations of tacks, the server operator SHOULD first provide
all servers with a new generation of tacks, and only then provide servers with
new tacks containing the new min_generation. Otherwise, a client might receive
a min_generation update from one server but then try to contact an
older-generation server which has not yet been updated.
</dd>
<dt>Tack expiration:</dt>
<dd>

When TACK is used in conjunction with certificates it is recommended to set
the tack expiration equal to the end-entity certificate's expiration (or a
later date), so that the tack and certificate can both be replaced at the same
time. Alternatively, short-lived tacks MAY be used so that a compromised TLS
private key has limited value to an attacker.
</dd>
<dt>Nonrevokable tacks</dt>
<dd>

A tack with generation 255 cannot be revoked. Such tacks MAY be used to
minimize the risk that a compromised TSK private key could be used to affect
site availability.


</dd>
<dt>Tack/pin activation:</dt>
<dd>

Tacks should only be activated once all TLS servers sharing the same hostname
have a tack. Otherwise, a client may activate a pin by contacting one server,
then contact a different server at the same hostname that does not yet have a
tack. 
</dd>
<dt>Tack/pin deactivation:</dt>
<dd>If all servers at a hostname deactivate
their tacks (by clearing the activation flags), all existing pins for the
hostname will eventually become inactive. The tacks can be removed after a
time interval equal to the maximum active period of any affected pins (30 days
at most).


</dd>
<dt>Tack/pin overlap:</dt>
<dd>When publishing overlapping tacks, the old and
new tacks SHOULD be active simultaneously for at least 60 days. This ensures
that any pin activation client who is contacting the server at intervals of 30
days or less will not have its activation periods interrupted. Example
process: activate new tacks; wait 60 days; deactivate old
tacks; wait 30 days; remove old tacks. 
</dd>
</dl></blockquote><p>

</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
For client implementers</h3>

<p>
</p>
<blockquote class="text"><dl>
<dt>Sharing pin information:</dt>
<dd>

It is possible for a client to maintain a pin store based entirely on its own
TLS connections. However, such a client runs the risk of creating incorrect
pins, failing to keep its pins active, or failing to receive min_generation
updates. Clients are advised to make use of 3rd-party trust infrastructure so
that pin data can be aggregated and shared. This will require additional
protocols outside the scope of this document.


</dd>
<dt>Clock synchronization:</dt>
<dd>

A client SHOULD take measures to prevent tacks from being erroneously rejected
as expired due to an inaccurate client clock. Such methods MAY include using
time synchronization protocols such as NTP <a class='info' href='#RFC5905'>[RFC5905]<span> (</span><span class='info'>Mills, D., Martin, J., Burbank, J., and W. Kasch, &ldquo;Network Time Protocol Version 4: Protocol and Algorithms Specification,&rdquo; June&nbsp;2010.</span><span>)</span></a>, or
accepting seemingly-expired tacks as valid if they expired less than T
minutes ago, where T is a "tolerance bound" set to the client's maximum
expected clock error.


</dd>
</dl></blockquote><p>

</p>
<a name="security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security considerations</h3>

<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
For server operators</h3>

<p>

All servers pinned to the same TSK can impersonate each other (see <a class='info' href='#servadvice'>Section&nbsp;7.1<span> (</span><span class='info'>For server operators</span><span>)</span></a>). Think carefully about this risk if using the same TSK
for multiple hostnames.


</p>
<p>

Make backup copies of the TSK private key and keep all copies in secure
locations where they can't be compromised.


</p>
<p>

A TSK private key MUST NOT be used to perform any non-TACK cryptographic
operations. For example, using a TSK for email encryption, code-signing, or
any other purpose MUST NOT be done.


</p>
<p>

HTTP cookies <a class='info' href='#RFC6265'>[RFC6265]<span> (</span><span class='info'>Barth, A., &ldquo;HTTP State Management Mechanism,&rdquo; April&nbsp;2011.</span><span>)</span></a> set by a pinned host can be stolen by a
network attacker who can forge web and DNS responses so as to cause a client
to send the cookies to a phony subdomain of the pinned host. To prevent this,
TACK HTTPS servers SHOULD set the "secure" attribute and omit the "domain"
attribute on all security-sensitive cookies, such as session cookies. These
settings tell the browser that the cookie should only be presented back to the
originating host (not its subdomains), and should only be sent over HTTPS (not
HTTP) <a class='info' href='#RFC6265'>[RFC6265]<span> (</span><span class='info'>Barth, A., &ldquo;HTTP State Management Mechanism,&rdquo; April&nbsp;2011.</span><span>)</span></a>.


</p>
<a name="security_client"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
For client implementers</h3>

<p>

A TACK pin store may contain private details of the client's connection
history. An attacker may be able to access this information by hacking or
stealing the client. Some information about the client's connection history
could also be gleaned by observing whether the client accepts or rejects
connections to phony TLS servers without correct tacks. To mitigate these
risks, a TACK client SHOULD allow the user to edit or clear the pin store.


</p>
<p>

Aside from possibly rejecting TLS connections, clients SHOULD NOT take any
actions which would reveal to a network observer the state of the client's pin
store, as this would allow an attacker to know in advance whether a
"man-in-the-middle" attack on a particular TLS connection will succeed or be
detected.


</p>
<p>

An attacker may attempt to flood a client with spurious tacks for different
hostnames, causing the client to delete old pins to make space for new ones.
To defend against this, clients SHOULD NOT delete active pins to make space
for new pins. Clients instead SHOULD delete inactive pins. If there are no
inactive pins to delete, then the pin store is full and there is no space for
new pins. To select an inactive pin for deletion, the client SHOULD delete the
pin with the oldest "end time".


</p>
<a name="future"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3"></a><h3>8.3.&nbsp;
Note on algorithm agility</h3>

<p>

If the need arises for tacks using different cryptographic algorithms (e.g.,
if SHA256 or ECDSA are shown to be weak), a "v2" version of tacks could be
defined, requiring assignment of a new TLS Extension number. Tacks as defined
in this document would then be known as "v1" tacks.


</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA considerations</h3>

<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
New entry for the TLS ExtensionType Registry</h3>

<p>

IANA is requested to add an entry to the existing TLS ExtensionType registry,
defined in <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a>, for "tack"(TBD) as defined in this
document.

 
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Acknowledgements</h3>

<p>

Valuable feedback has been provided by Adam Langley, Chris Palmer, Nate
Lawson, and Joseph Bonneau.


</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.&nbsp;Normative references</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="FIPS180-2">[FIPS180-2]</a></td>
<td class="author-text">National Institute of Standards and Technology, &ldquo;<a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf">Secure Hash Standard</a>,&rdquo; FIPS&nbsp;PUB 180-2, August&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="FIPS186-3">[FIPS186-3]</a></td>
<td class="author-text">National Institute of Standards and Technology, &ldquo;<a href="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf">Digital Signature Standard</a>,&rdquo; FIPS&nbsp;PUB 186-3, June&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3207">[RFC3207]</a></td>
<td class="author-text">Hoffman, P., &ldquo;<a href="http://tools.ietf.org/html/rfc3207">SMTP Service Extension for Secure SMTP over Transport Layer Security</a>,&rdquo; RFC&nbsp;3207, February&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3207.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4648">[RFC4648]</a></td>
<td class="author-text">Josefsson, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>,&rdquo; RFC&nbsp;4648, October&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4648.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5246">[RFC5246]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>,&rdquo; RFC&nbsp;5246, August&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5246.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5280">[RFC5280]</a></td>
<td class="author-text">Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>,&rdquo; RFC&nbsp;5280, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5280.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5480">[RFC5480]</a></td>
<td class="author-text">Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk, &ldquo;<a href="http://tools.ietf.org/html/rfc5480">Elliptic Curve Cryptography Subject Public Key Information</a>,&rdquo; RFC&nbsp;5480, March&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5480.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5905">[RFC5905]</a></td>
<td class="author-text">Mills, D., Martin, J., Burbank, J., and W. Kasch, &ldquo;<a href="http://tools.ietf.org/html/rfc5905">Network Time Protocol Version 4: Protocol and Algorithms Specification</a>,&rdquo; RFC&nbsp;5905, June&nbsp;2010 (<a href="http://www.rfc-editor.org/rfc/rfc5905.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC6066">[RFC6066]</a></td>
<td class="author-text">Eastlake, D., &ldquo;<a href="http://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>,&rdquo; RFC&nbsp;6066, January&nbsp;2011 (<a href="http://www.rfc-editor.org/rfc/rfc6066.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC6090">[RFC6090]</a></td>
<td class="author-text">McGrew, D., Igoe, K., and M. Salter, &ldquo;<a href="http://tools.ietf.org/html/rfc6090">Fundamental Elliptic Curve Cryptography Algorithms</a>,&rdquo; RFC&nbsp;6090, February&nbsp;2011 (<a href="http://www.rfc-editor.org/rfc/rfc6090.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC6265">[RFC6265]</a></td>
<td class="author-text">Barth, A., &ldquo;<a href="http://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a>,&rdquo; RFC&nbsp;6265, April&nbsp;2011 (<a href="http://www.rfc-editor.org/rfc/rfc6265.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Moxie Marlinspike</td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Trevor Perrin (editor)</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:tack@trevp.net">tack@trevp.net</a></td></tr>
</table>
